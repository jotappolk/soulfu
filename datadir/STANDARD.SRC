//-----------------------------------------------------------------------
// <ZZ> This file contains standard functions for character & item scripts...
//-----------------------------------------------------------------------
#define GLOBAL_EXPERIENCE_MODIFIER 0.50  // Make higher to make level ups easier...


//-----------------------------------------------------------------------
int DamageSoundEvent(int oof, int eef, int death)
  int self, pitch

  self = FindSelf()
  if(self.event == EVENT_DAMAGED && oof)
    pitch = 235 + RollDice(1, 40)
    if(self.pttimer > 0)
      if(self.hits > 0)
        PlaySound("FILE:-STATU01.RAW", pitch, 255)
      else
        PlaySound("FILE:-STATU03.RAW", pitch, 255)
    else
      if(self.hits > 0)
        if(RollDice(1, 2) == 1)
          PlaySound(oof, pitch, 255)
        else
          if(eef)
            PlaySound(eef, pitch, 255)
          else
            PlaySound(oof, pitch, 255)
      else
        if(death)
          PlaySound(death, pitch, 255)
        else
          PlaySound(oof, pitch, 255)


//-----------------------------------------------------------------------
// <ZZ> Function that allows character type change of level up...
int LevelUpChange(int script)
  int self, rider, child, index

  self = FindSelf()

  SetSpawnTeam(self.team)
  SetSpawnOwner(FindIndex(self))
  SetSpawnSubtype(self.eqcol01)
  child = Spawn(CHARACTER, self.x, self.y, self.z, script)
  if(child)
    child.spin = self.spin
    child.flatten = 60
    child.aitimer = 1
    StringClear(child.name)
    StringAppend(child.name, self.name, 16)

    child.level = self.level
    child.exp = self.exp
    child.hitsmax = self.hitsmax
    child.hitstap = self.hitstap
    child.hits = self.hits
    child.manamax = self.manamax
    child.manatap = self.manatap
    child.mana = self.mana
    child.str = self.str
    child.dex = self.dex
    child.int = self.int
    child.vircomp = self.vircomp
    child.virdill = self.virdill
    child.virhono = self.virhono
    child.virfait = self.virfait
    child.vircour = self.vircour
    child.money = self.money
    child.eqleft = self.eqleft
    child.eqright = self.eqright
    child.eqspec1 = self.eqspec1
    child.eqspec2 = self.eqspec2
    child.item00 = self.item00
    child.item01 = self.item01
    child.item02 = self.item02
    child.item03 = self.item03
    child.item04 = self.item04
    child.item05 = self.item05
    child.item06 = self.item06
    child.item07 = self.item07
    child.item08 = self.item08
    child.item09 = self.item09
    child.item10 = self.item10
    child.item11 = self.item11
    child.item12 = self.item12
    child.item13 = self.item13
    child.item14 = self.item14
    child.item15 = self.item15

    child.eflags = self.eflags & (255 - ENCHANT_FLAG_LEVITATE)
    child.morphoc = self.morphoc
    child.owner = self.owner
    child.pstimer = self.pstimer
    child.pttimer = self.pttimer
    child.alpha = self.alpha
    child.nctimer = 15
    child.food = self.food
    if(self.vflags & VIRTUE_FLAG_EATS_TRIPE)
      child.vflags = child.vflags | VIRTUE_FLAG_EATS_TRIPE

    FixCharacterLocation(child)
    SetupTargetMatrix(child)
    // If we had a rider, knock 'em off...
    rider = FindByIndex(self.rider)
    if(rider)
      if(rider.mount == FindIndex(self))
        rider.mount = 65535
        rider.action = ACTION_STAND
        rider.daction = ACTION_STAND
        rider.event = EVENT_DISMOUNTED
        SystemSet(SYS_CHARFASTFUNCTION, FindIndex(rider), 0, FAST_FUNCTION_EVENT)
    SystemSet(SYS_SWAPCHARACTERS, 0, FindIndex(child), FindIndex(self))
    index = self.target
    self.target = FindIndex(child)
    GoPoof(POOF_TARGET)
    self.target = index
    return TRUE



//-----------------------------------------------------------------------
// <ZZ> Function that should be called in every character's Event() function,
//      to allow helper pets to level up well...  Also throws off a little
//      "Level Up!" particle and makes the sound...
int LevelUpEvent(int hits_add, int mana_add, int str_add, int dex_add, int int_add)
  int self, child


  self = FindSelf()
  if(self.event == EVENT_LEVEL_UP && self.team == TEAM_GOOD)
    if(IndexIsLocalPlayer(FindIndex(self)) || IndexIsLocalPlayer(self.owner))
      PlayMegaSound("FILE:BAD2.RAW", 256, 255, 128, NULL)
      child = PBACKSTB.Effect("FILE:=LEVELUP.RGB", 0, self.x, self.y, self.z+self.height*0.5)
      if(child)
        child.red = 255
        child.green = 255
        child.blue = 255
      PFLASH.Effect(self, "FILE:=MPDUST.RGB", WHITE, TRUE, 0.9)
      PFLASH.Effect(self, "FILE:=MPDUST.RGB", DARK_BLUE, FALSE, 1.0)
      if(!IndexIsLocalPlayer(FindIndex(self)))
        // We're a pet, so automagically spend all of our stat points...
        self.hitsmax = self.hitsmax + hits_add
        self.hits = self.hits + hits_add
        self.manamax = self.manamax + mana_add
        self.mana = self.mana + mana_add
        self.str = self.str + str_add
        self.dex = self.dex + dex_add
        self.int = self.int + int_add
        self.statpts = 0
      return (self.level >= 5)
    return FALSE
  return FALSE

//-----------------------------------------------------------------------
// <ZZ> Helper for doing little charge ball for a spell...
int ChargeEffect(float x, float y, float z, int image, int halo, int charge)


  // Big charge ball...
  if(halo)
    PCHARGE.BallAlphaEffect(x, y, z, charge*0.024, image, 128)
    PCHARGE.BallAlphaEffect(x, y, z, charge*0.012, image, 128)
  else
    PCHARGE.BallAlphaEffect(x, y, z, charge*0.018, image, 255)


  // Spikes...
  PCHARGE.SpikeEffect(x, y, z, charge, image)

//-----------------------------------------------------------------------
// <ZZ> Helper for doing dismounting of characters, based on the
//      rider's equipment setup (which slot is used for jump)...
//      Also sets the Rider's button flags so levitate works
//      correctly coming off a mount...
int RiderDismountButton()
  int rider, self, event
  float oldz
  self = FindSelf()
  rider = FindByIndex(self.rider)
  event = self.event & 7
  if(rider)
    oldz = rider.z
    if(event == BUTTON_LEFT)
      if(rider.eqleft == ITEM_JUMP)
        rider.bflags = rider.bflags | 1
        Dismount()
        if(rider.z < oldz)
          rider.z = oldz
        ButtonHandled()
        return TRUE
    if(event == BUTTON_RIGHT)
      if(rider.eqright == ITEM_JUMP)
        rider.bflags = rider.bflags | 2
        Dismount()
        if(rider.z < oldz)
          rider.z = oldz
        ButtonHandled()
        return TRUE
    if(event == BUTTON_SPECIAL1)
      if(rider.eqspec1 == ITEM_JUMP)
        rider.bflags = rider.bflags | 4
        Dismount()
        if(rider.z < oldz)
          rider.z = oldz
        ButtonHandled()
        return TRUE
    if(event == BUTTON_SPECIAL2)
      if(rider.eqspec2 == ITEM_JUMP)
        rider.bflags = rider.bflags | 8
        Dismount()
        if(rider.z < oldz)
          rider.z = oldz
        ButtonHandled()
        return TRUE
  return FALSE

//-----------------------------------------------------------------------
// Spawns the effect particles for enchanted weapons...  Should only be
// called from an in-hand item's Refresh() script...  Percent
// is the percent chance of spawning a particle...  Scale is 1.0
// for normal sized particles
WeaponRefresh(int percent, float scale)
  int enchantment, i
  int self, owner_index, child
  int image1, image2, color
  int smoke_image1, smoke_image2, smoke_color, bone
  float x, y, z, size


  if(SystemGet(SYS_MAINGAMEFRAME, 0, 0) & 1)
    enchantment = SystemGet(SYS_ITEMINDEX, 0, 0)&7
    if(enchantment)
      if(enchantment == WEAPON_VARIANT_VOLT)
        SystemSet(SYS_WEAPONREFRESHFLASH, BLUE, BLACK, 20)
        i = 0
        while(i < 6)
          SystemSet(SYS_WEAPONREFRESHXYZ, 0, 0, 0)
          x = SystemGet(SYS_WEAPONREFRESHXYZ, 0, 0) * 0.001
          y = SystemGet(SYS_WEAPONREFRESHXYZ, 0, 1) * 0.001
          z = SystemGet(SYS_WEAPONREFRESHXYZ, 0, 2) * 0.001
          if(RollDice(1, 100) <= percent)
            PCHARGE.SpikeEffect(x, y, z, 32+RollDice(1, 100), "FILE:ZAPPY1.RGB")
          i++
        return TRUE


      self = FindSelf()
      owner_index = FindIndex(self)
      SystemSet(SYS_WEAPONREFRESHXYZ, 0, 0, 0)
      x = SystemGet(SYS_WEAPONREFRESHXYZ, 0, 0) * 0.001
      y = SystemGet(SYS_WEAPONREFRESHXYZ, 0, 1) * 0.001
      z = SystemGet(SYS_WEAPONREFRESHXYZ, 0, 2) * 0.001
      size = ((RollDice(1, 50)*0.01)+0.50)*scale
      image1 = "FILE:=MPDUST.RGB"
      image2 = NULL
      color = WHITE
      smoke_image1 = "FILE:=MPDUST.RGB"
      smoke_image2 = NULL
      smoke_color = (128)
      if(enchantment == WEAPON_VARIANT_MAGIC)
        smoke_color = (128<<16) + (128<<8) + (255)
        SystemSet(SYS_WEAPONREFRESHFLASH, smoke_color, WHITE, 30)
        if(RollDice(1, 100) <= percent)
          smoke_color = (64<<16) + (64<<8) + (64)
          image1 = "FILE:SPARK2.RGB"
          PENCHANT.Effect(x, y, z-0.2, 0.03, size + 0.125, image1, image1, TRUE, smoke_color, owner_index)
        if((SystemGet(SYS_MAINGAMEFRAME, 0, 0) & 31) == 1)
          if(RollDice(1, 100) <= percent)
            PEMBER.Effect(x, y, z, 0.0, 0.0, -0.05, 0.50, 128, 2, "FILE:STAR0.RGB")
        return TRUE
      if(enchantment == WEAPON_VARIANT_HOLY)
        smoke_color = (255<<16) + (192<<8) + (128)
        SystemSet(SYS_WEAPONREFRESHFLASH, smoke_color, WHITE, 30)
        if(RollDice(1, 100) <= percent)
          image1 = "FILE:SPARK4.RGB"
          PENCHANT.Effect(x, y, z-0.2, 0.03, size + 0.125, image1, image1, TRUE, smoke_color, owner_index)
        if((SystemGet(SYS_MAINGAMEFRAME, 0, 0) & 31) == 1)
          if(RollDice(1, 100) <= percent)
            PEMBER.Effect(x, y, z, 0.0, 0.0, 0.05, 0.50, 192, 2, "FILE:SPARK4.RGB")
        if(self.action == ACTION_SPECIAL_1)
          if(self.frame == 570 || self.frame == 571)
            bone = SystemGet(SYS_WEAPONREFRESHBONENAME, 0, 0)
            if(bone == 1)
              // Left handed holy weapon always heals...
              RestoreCharacterHits(self, 1, 0)
            if(bone == 2)
              // Right handed holy weapon only heals if left isn't holy...
              if(self.eqleft < ITEM_DAGGER || self.eqleft > (ITEM_WAR_HAMMER+7) || (self.eqleft&7)!=WEAPON_VARIANT_HOLY)
                RestoreCharacterHits(self, 1, 0)
        return TRUE
      if(enchantment == WEAPON_VARIANT_FIRE)
        SystemSet(SYS_WEAPONREFRESHFLASH, RED, DARK_RED, 30)
        image1 = "FILE:FIRE0.RGB"
        image2 = "FILE:FIRE1.RGB"
      if(enchantment == WEAPON_VARIANT_ICE)
        SystemSet(SYS_WEAPONREFRESHFLASH, CYAN, BLUE, 30)
        image1 = "FILE:ICE0.RGB"
        image2 = "FILE:ICE1.RGB"
        smoke_color = (4239600)
      if(enchantment == WEAPON_VARIANT_POISON)
        SystemSet(SYS_WEAPONREFRESHFLASH, GREEN, (128<<8), 30)
        if(RollDice(1, 200) < 3)
          PDRIP.Effect(x, y, z, 0.0, 0.0, -0.01, (255<<8), 10, 10)
        return TRUE
      if(enchantment == WEAPON_VARIANT_UNHOLY)
        SystemSet(SYS_WEAPONREFRESHFLASH, BLACK, BLACK, 30)
        i = 0
        while(i < 2)
          SystemSet(SYS_WEAPONREFRESHXYZ, 0, 0, 0)
          x = SystemGet(SYS_WEAPONREFRESHXYZ, 0, 0) * 0.001
          y = SystemGet(SYS_WEAPONREFRESHXYZ, 0, 1) * 0.001
          z = SystemGet(SYS_WEAPONREFRESHXYZ, 0, 2) * 0.001
          if(RollDice(1, 100) <= percent)
            PSMOKE.Effect(x, y, z, 0.0005*(RollDice(1, 200)-100), 0.0005*(RollDice(1, 200)-100), 0.0, scale, 0.97, TRUE, DARK_RED, 128, 30)
          i++
        if((SystemGet(SYS_MAINGAMEFRAME, 0, 0) & 2047) == 2047)
          if(self.virfait > 0 && self.virfait < 255)
            self.virfait--
        if(self.food > 2)
          self.food--
          self.food--
          if(self.virfait == 255 && self.food > 4)
            // The virtuous starve even more...
            self.food = self.food-4
        return TRUE
      if(RollDice(1, 100) <= percent)
        PENCHANT.Effect(x, y, z-0.4, 0.06, size, image1, image2, TRUE, color, owner_index)
        PENCHANT.Effect(x, y, z-0.4, 0.07, size + 0.5, smoke_image1, smoke_image2, FALSE, smoke_color, owner_index)

//-----------------------------------------------------------------------
// Fixes stats of a monster when spawned to make sure it can
// use its equipped items...
int FixStatsToItem(int self, int item_index)
  int reqstr, reqdex, reqint, reqmana, item, i
  if(self && item_index != ITEM_NONE)
    reqstr = SystemGet(SYS_ITEMREGISTRYSTR, item_index, 0)
    reqdex = SystemGet(SYS_ITEMREGISTRYDEX, item_index, 0)
    reqint = SystemGet(SYS_ITEMREGISTRYINT, item_index, 0)
    reqmana = SystemGet(SYS_ITEMREGISTRYMANA, item_index, 0)
    if(reqstr > self.str)
      self.str = reqstr
    if(reqdex > self.dex)
      self.dex = reqdex
    if(reqint > self.int)
      self.int = reqint
    if(reqmana > self.manamax)
      self.manamax = reqmana
      self.mana = self.manamax
    return TRUE
  return FALSE 
int FixStats(int self)
  if(self)
    FixStatsToItem(self, self.eqleft)
    FixStatsToItem(self, self.eqright)
    FixStatsToItem(self, self.eqspec1)
    FixStatsToItem(self, self.eqspec2)
    return TRUE
  return FALSE

//-----------------------------------------------------------------------
// Fills in the item name, giving damage range and adjusting for stats and
// enchants...  Also handles stat requirements and parenthetical text...
ItemName(int base_text, int paren_text, int damage_type, int damage_low, int damage_high, int wound_low, int wound_high)
  int enchantment, item_index
  int binding, strength, reqstr, reqdex, reqint, reqmana
  binding = FindBinding()
  item_index = SystemGet(SYS_ITEMINDEX, 0, 0)
  strength = 0
  reqstr = 0
  reqdex = 0
  reqint = 0
  reqmana = 0
  if(binding)
    strength = binding.str
    reqstr = SystemGet(SYS_ITEMREGISTRYSTR, item_index, 0)
    reqdex = SystemGet(SYS_ITEMREGISTRYDEX, item_index, 0)
    reqint = SystemGet(SYS_ITEMREGISTRYINT, item_index, 0)
    reqmana = SystemGet(SYS_ITEMREGISTRYMANA, item_index, 0)
    if(reqstr <= binding.str)
      reqstr = 0
    if(reqdex <= binding.dex)
      reqdex = 0
    if(reqint <= binding.int)
      reqint = 0
    if(reqmana <= binding.manamax)
      reqmana = 0


  StringClear(NAME_STRING)
  StringAppend(NAME_STRING, base_text, 256)
  if(reqstr > 0 || reqint > 0 || reqdex > 0 || reqmana > 0)
    // Item is unuseable...  Tell which stats are unmet...
    StringAppend(NAME_STRING, " (NEED ", 256)
    if(reqstr > 0)
      StringAppendNumber(NAME_STRING, reqstr, 256)
      StringAppend(NAME_STRING, " STR", 256)
      if(reqdex > 0 || reqint > 0 || reqmana > 0)
        StringAppend(NAME_STRING, ", ", 256)
    if(reqdex > 0)
      StringAppendNumber(NAME_STRING, reqdex, 256)
      StringAppend(NAME_STRING, " DEX", 256)
      if(reqint > 0 || reqmana > 0)
        StringAppend(NAME_STRING, ", ", 256)
    if(reqint > 0)
      StringAppendNumber(NAME_STRING, reqint, 256)
      StringAppend(NAME_STRING, " INT", 256)
      if(reqmana > 0)
        StringAppend(NAME_STRING, ", ", 256)
    if(reqmana > 0)
      StringAppendNumber(NAME_STRING, reqmana, 256)
      StringAppend(NAME_STRING, " MANA", 256)
    StringAppend(NAME_STRING, ")", 256)
  else
    // Is the damage type valid?
    if(damage_type > DAMAGE_WOUND)
      // No it's not...  That means we need to display the
      // parenthetical text...
      if(paren_text)
        StringAppend(NAME_STRING, " (", 256)
        StringAppend(NAME_STRING, paren_text, 256)
        StringAppend(NAME_STRING, ")", 256)
    else
      // Show weapon's modified damage ratings...
      if(item_index > 135 && item_index < 232)
        // Item is an enchantable weapon...
        enchantment = item_index&7
        if(enchantment == WEAPON_VARIANT_MAGIC)
          damage_low++
          damage_high++
        if(enchantment == WEAPON_VARIANT_FIRE)
          damage_low = damage_low + 2
          damage_high = damage_high + 2
          damage_type = DAMAGE_FIRE
        if(enchantment == WEAPON_VARIANT_ICE)
          damage_low = damage_low + 2
          damage_high = damage_high + 2
          damage_type = DAMAGE_ICE
        if(enchantment == WEAPON_VARIANT_VOLT)
          damage_low = damage_low + 2
          damage_high = damage_high + 2
          damage_type = DAMAGE_VOLT
        if(enchantment == WEAPON_VARIANT_HOLY)
          wound_low++
          wound_high++
        if(enchantment == WEAPON_VARIANT_UNHOLY)
          damage_low = damage_low + 3
          damage_high = damage_high + 3
        damage_low = damage_low + (strength/10)
        damage_high = damage_high + (strength/10)
      ItemNameDamage(damage_type, damage_low, damage_high, wound_low, wound_high)


//-----------------------------------------------------------------------
int NameAppendHits()
  int self, rider, child
  float x, y

  self = FindSelf()


  // Make helpers stand still if we mouse over 'em...
  if(self.team == TEAM_GOOD && self.aitimer > 0)
    self.gotox = self.x
    self.gotoy = self.y
    self.aitimer = 5


    // Also let us click on 'em for a helper window...
    if(SystemGet(SYS_CURSORBUTTONPRESSED, 0, 0))
      if(!SystemGet(SYS_ENCHANTCURSOR, 0, ENCHANT_CURSOR_ACTIVE))
        child = FindWindow(FindIndex(self), "FILE:WHELPER.RUN")
        if(child)
          // Close the existing helper window if it's open...
          child.stat00l = 250
        else
          // Just so we don't make the sound twice...
          ButtonSound()


        // Open a new helper window...
        x = SystemGet(SYS_CURSORSCREENPOS, 0, 0)
        y = SystemGet(SYS_CURSORSCREENPOS, 0, 1)
        child = Spawn(WINDOW, x, y+10.0, 0.0, "FILE:WHELPER.RUN")
        if(child)
          child.binding = FindIndex(self)
          StringClear(child.string0)
          StringAppend(child.string0, NAME_STRING, 32)


  // Make character name take precedence over scripted name...
  if(FileReadByte(self, 144) != 0)
    // Character has a name...
    FileWriteByte(self, 159, 0)
    StringClear(NAME_STRING)
    StringAppend(NAME_STRING, self.name, 16)



//  StringAppend(NAME_STRING, "<", 256)
//  StringAppendNumber(NAME_STRING, self.mount, 256)
//  StringAppend(NAME_STRING, ">", 256)
//  StringAppend(NAME_STRING, "<", 256)
//  StringAppendNumber(NAME_STRING, self.rider, 256)
//  StringAppend(NAME_STRING, ">", 256)



  // Append hit numbers...
  rider = FindByIndex(self.rider)
  if(self.team == TEAM_GOOD && (self.aitimer > 0 || rider))
    // Hits numbers...
    StringAppend(NAME_STRING, " (", 256)
    StringAppendNumber(NAME_STRING, self.hits, 256)
    StringAppend(NAME_STRING, "/", 256)
    StringAppendNumber(NAME_STRING, self.hitsmax, 256)
    StringAppend(NAME_STRING, ")", 256)
          

    if(self.manamax > 0)
      StringAppend(NAME_STRING, " (", 256)
      StringAppendNumber(NAME_STRING, self.mana, 256)
      StringAppend(NAME_STRING, "/", 256)
      StringAppendNumber(NAME_STRING, self.manamax, 256)
      StringAppend(NAME_STRING, ")", 256)



//-----------------------------------------------------------------------
// Accumulates the defense stats for a character based on armor types...
DefenseRating()
  int self

  self = FindSelf()
  SystemSet(SYS_CLEARDEFENSERATING, 0, 0, 0)
  if(self.sflags & SCRIPT_ALLOW_HELM)
    SystemSet(SYS_ITEMDEFENSERATING, 0, 0, self.eqhelm)
  if(self.sflags & SCRIPT_ALLOW_BODY)
    SystemSet(SYS_ITEMDEFENSERATING, 0, 0, self.eqbody)
  if(self.sflags & SCRIPT_ALLOW_LEGS)
    SystemSet(SYS_ITEMDEFENSERATING, 0, 0, self.eqlegs)
  SystemSet(SYS_ITEMDEFENSERATING, 0, 0, self.eqleft)
  SystemSet(SYS_ITEMDEFENSERATING, 0, 0, self.eqright)
  self.defedge = SystemGet(SYS_DEFENSERATING, 0, DAMAGE_EDGE)
  self.defbash = SystemGet(SYS_DEFENSERATING, 0, DAMAGE_BASH)
  self.defacid = SystemGet(SYS_DEFENSERATING, 0, DAMAGE_ACID)
  self.deffire = SystemGet(SYS_DEFENSERATING, 0, DAMAGE_FIRE)
  self.defice  = SystemGet(SYS_DEFENSERATING, 0, DAMAGE_ICE)
  self.defvolt = SystemGet(SYS_DEFENSERATING, 0, DAMAGE_VOLT)
  self.defwoun = SystemGet(SYS_DEFENSERATING, 0, DAMAGE_WOUND)

//-----------------------------------------------------------------------
// Helper for armor items...  So magical variants give bonus...
int DefenseBoost(int variant, int multiplier)
  if(variant == ARMOR_VARIANT_NONE)
    return FALSE
  SystemSet(SYS_DEFENSERATING, 0, DAMAGE_EDGE, 1)
  SystemSet(SYS_DEFENSERATING, 0, DAMAGE_BASH, 1)
  if(variant == ARMOR_VARIANT_FIRE)
    SystemSet(SYS_DEFENSERATING, 0, DAMAGE_FIRE, multiplier)
    return TRUE
  if(variant == ARMOR_VARIANT_ICE)
    SystemSet(SYS_DEFENSERATING, 0, DAMAGE_ICE, multiplier)
    return TRUE

//-----------------------------------------------------------------------
// Lots of combat type spells share this script...
int SpellEffect(int self, int mana_cost, int mana_tap)
  int min_int, item_type, index, dex

  if(self)
    if(self.action == ACTION_WALK || self.action == ACTION_STAND || self.action == ACTION_JUMP || self.action == ACTION_DOUBLE)
      ButtonHandled()
      item_type = SystemGet(SYS_ITEMINDEX, 0, 0)
      min_int = SystemGet(SYS_ITEMREGISTRYINT, item_type, 0)
      if(self.int >= min_int && MagicWillWork(self.manamax, self.mana, mana_cost))
        if(STANDARD.ItemReload(self))
          self.mana = self.mana-mana_cost
          self.manatap = self.manatap+mana_tap
          self.action = ACTION_MAGIC
          self.daction = ACTION_STAND
          index = FindIndex(self)
          SetSpawnOwner(index)
          SetSpawnTeam(self.team)
          PDELAY.Effect(item_type, self.x, self.y, self.z+self.height)
          return TRUE
      else
        if(IndexIsLocalPlayer(FindIndex(self)))
          BuzzerSound()
  return FALSE

//-----------------------------------------------------------------------
// Helper for figgerin' if a character can grab a dropped particle...
int ParticleGrabTarget()
  int target, rider

  target = FindTarget()
  if(target)
    rider = FindByIndex(target.rider)
    if(rider)
      target = rider
    if(target.team == TEAM_GOOD)
      if(target.aitimer == 0)
        return target
  return NULL

//-----------------------------------------------------------------------
// Makes a character drop all of its PDROP items...
int DropItems()
  int i, count, item_type, self
  float angle, angle_add, vx, vy, scale



  // Go through inventory counting items...  Also make
  // meat & porc rotten if character is poison'd
  self = FindSelf()
  count = 0
  i = 224
  while(i < 246)
    if(i != 240 && i != 241)
      if(self.pstimer > 15)
        item_type = FileReadByte(self, i)
        if(item_type == ITEM_PORC)
          FileWriteByte(self, i, ITEM_PORC_ROTTEN)
        if(item_type == ITEM_MEAT)
          FileWriteByte(self, i, ITEM_MEAT_ROTTEN)
      count = count + DropItemsHelper(i, FALSE, 0.0, 0.0)
    i++



  // Now drop any we found
  if(count > 0)
    angle = RollDice(1, 100)*3.60
    scale = 0.1
    angle_add = 360.0 / count
    i = 224
    while(i < 246)
      if(i != 240 && i != 241)
        vx = sin(angle)*scale
        vy = sin(angle+90.0)*scale
        if(DropItemsHelper(i, TRUE, vx, vy))
          angle = angle + angle_add
      i++
  return count


//-----------------------------------------------------------------------
// Helper for the above...
int DropItemsHelper(int slot, int do_drop, float vx, float vy)
  int self, item_type

  self = FindSelf()
  item_type = FileReadByte(self, slot)
  if(item_type >= ITEM_QUIVER_10 && item_type <= ITEM_QUIVER_3)
    if(do_drop)
      PDROP.Effect(self.x, self.y, self.z+2.0, vx, vy, 0.5, 2.0, "FILE:=DRPQUIV.RGB", ITEM_QUIVER_10)
      FileWriteByte(self, slot, ITEM_NONE)
    return TRUE
  if(item_type == ITEM_MEAT_ROTTEN)
    if(do_drop)
      PDROP.Effect(self.x, self.y, self.z+2.0, vx, vy, 0.5, 2.0, "FILE:=DRPROTT.RGB", item_type)
      FileWriteByte(self, slot, ITEM_NONE)
    return TRUE
  if(item_type == ITEM_MEAT)
    if(do_drop)
      PDROP.Effect(self.x, self.y, self.z+2.0, vx, vy, 0.5, 2.0, "FILE:=DRPMEAT.RGB", item_type)
      FileWriteByte(self, slot, ITEM_NONE)
    return TRUE
  if(item_type == ITEM_PORC_ROTTEN)
    if(do_drop)
      PDROP.Effect(self.x, self.y, self.z+2.0, vx, vy, 0.5, 2.0, "FILE:=DRPPORR.RGB", item_type)
      FileWriteByte(self, slot, ITEM_NONE)
    return TRUE
  if(item_type == ITEM_PORC)
    if(do_drop)
      PDROP.Effect(self.x, self.y, self.z+2.0, vx, vy, 0.5, 2.0, "FILE:=DRPPORC.RGB", item_type)
      FileWriteByte(self, slot, ITEM_NONE)
    return TRUE
  if(item_type == ITEM_FISH)
    if(do_drop)
      PDROP.Effect(self.x, self.y, self.z+2.0, vx, vy, 0.5,1.25, "FILE:=DRPFISH.RGB", item_type)
      FileWriteByte(self, slot, ITEM_NONE)
    return TRUE
  if(item_type == ITEM_COOKIE)
    if(do_drop)
      PDROP.Effect(self.x, self.y, self.z+2.0, vx, vy, 0.5,1.25, "FILE:=DRPCOOK.RGB", item_type)
      FileWriteByte(self, slot, ITEM_NONE)
    return TRUE
  if(item_type == ITEM_HEAL)
    if(do_drop)
      PDROP.Effect(self.x, self.y, self.z+2.0, vx, vy, 0.5,1.75, "FILE:=DRPHEAL.RGB", item_type)
      FileWriteByte(self, slot, ITEM_NONE)
    return TRUE
  if(item_type == ITEM_MANA)
    if(do_drop)
      PDROP.Effect(self.x, self.y, self.z+2.0, vx, vy, 0.5,1.75, "FILE:=DRPMANA.RGB", item_type)
      FileWriteByte(self, slot, ITEM_NONE)
    return TRUE
  if(item_type == ITEM_SUPER_HEAL)
    if(do_drop)
      PDROP.Effect(self.x, self.y, self.z+2.0, vx, vy, 0.5,1.75, "FILE:=DRPSHEA.RGB", item_type)
      FileWriteByte(self, slot, ITEM_NONE)
    return TRUE
  if(item_type == ITEM_SUPER_MANA)
    if(do_drop)
      PDROP.Effect(self.x, self.y, self.z+2.0, vx, vy, 0.5,1.75, "FILE:=DRPSMAN.RGB", item_type)
      FileWriteByte(self, slot, ITEM_NONE)
    return TRUE
  return FALSE


//-----------------------------------------------------------------------
// Spawn some particles and items when a character dies...
int DeathEffect()
  int self

  self = FindSelf()
  PSPARK.Effect(self.x, self.y, self.z, 30, 3)


  if(self.money > 0 || self.keys > 0)
    // We've got some coins and keys, so drop 'em...
    if(SystemGet(SYS_LUCK, 0, 0) && self.money > 0)
      // Luck gives a few extra coins...
      if(self.team == TEAM_MONSTER || self.team == TEAM_EVIL)
        self.money = self.money + RollDice(1, 5)
    PCOIN.Effect(self.money, self.x, self.y, self.z)
    PKEY.Effect(self.keys, self.x, self.y, self.z)
  else
    // Only monsters and evil guys drop hearts & items...
    if(self.team == TEAM_MONSTER || self.team == TEAM_EVIL)
      if(DropItems() == FALSE)
        // Didn't have any items to drop, so let's try hearts...
        if(RollDice(1, 100) > 60)
          PHEART.Effect(RED_HEART, self.x, self.y, self.z+2.0, 0.0, 0.0, 0.0)
      
//-----------------------------------------------------------------------
// Returns TRUE if the character is a helper and has a Wunnup's Cup, and also
// heals that character.  Returns FALSE otherwise
int HelperRespawn()
  int self, script_file, child
  self = FindSelf()
  if(self)
    if(self.team == TEAM_GOOD)
      if(IndexIsLocalPlayer(self.owner))
        if(!(self.oflags & OTHER_FLAG_NO_HEARTS))
          if(CharacterHasItem(self, ITEM_ONE_UP, TRUE))
            script_file = SystemGet(SYS_CHARACTERSCRIPTFILE, 0, FindIndex(self))
            if(script_file)
              child = Spawn(CHARACTER, 0.0, 0.0, 20.0, script_file)
              if(child)
                // !!!BAD!!!
                // !!!BAD!!! Position character better...
                // !!!BAD!!!
                self.x = 0.0
                self.y = 0.0
                self.z = RoomHeightXY(self.x, self.y)
                // !!!BAD!!!
                // !!!BAD!!!
                // !!!BAD!!!
                self.hits = self.hitsmax
                self.hitstap = 0
                self.rltimer = 30
                self.rrtimer = 30
                self.intimer = 60
                self.action = child.action
                self.daction = child.action
                if(script_file == "FILE:CZOMBI.RUN")
                  self.action = ACTION_STAND
                  self.daction = ACTION_STAND
                  child.flags = child.flags & (65535-CHAR_NO_COLLISION)
                  child.alpha = 255
                self.flags = child.flags
                self.sflags = child.sflags
                self.vspin = child.vspin
                self.bright = child.bright
                if(self.theight > self.height)
                  self.height = self.theight
                self.boxsize = child.boxsize
                self.pttimer = 0
                self.pstimer = 0
                self.money = 0
                self.keys = 0
                self.aitimer = 1


                // Do the respawn effect...
                PlaySound("FILE:-GONG0.RAW", 256, 255)
                PFLASH.FocusEffect(self.x, self.y, self.z+(self.height*0.5), self.boxsize+self.height, "FILE:LITESPRK.RGB", 25)
                PFLASH.Effect(self, "FILE:LITESPRK.RGB", WHITE, TRUE, 1.5)
                PFLASH.Effect(self, "FILE:LITESPRK.RGB", (128<<16) | (128<<8) | 128, TRUE, 4.0)


                // Get rid of the temporary character...
                self.target = FindIndex(child)
                GoPoof(POOF_TARGET_STUCK_PARTICLES)
                GoPoof(POOF_TARGET)
                return TRUE
  return FALSE

//-----------------------------------------------------------------------
// Used to make object's be destroyed in place (rather than bouncing around)
int SimpleDamageEvent()
  int self
  self = FindSelf()
  self.lasthit = SystemGet(SYS_GLOBALATTACKER, 0, 0)
  self.vz = 0.20
  self.dmtimer = 20
  self.intimer = 20
  if(self.combo > 3)
    Dismount()
  if(self.hits == 0)
    GiveExperience()
    Dismount()
    DeathEffect()
    if(!HelperRespawn())
      GoPoof(POOF_SELF)
  return 0

//-----------------------------------------------------------------------
// Used to spawn riders on top of their mounts (can be called from either
// a mount's spawn script or a rider's spawn script)...  Returns TRUE if
// it worked...  Doesn't work for good guys (or it might get annoying going
// from room to room)...
int PutOnMount()
  int self, target, i
  float x, y, dis, checkdis


  self = FindSelf()
  if(self.team == TEAM_GOOD)
    return FALSE
  i = 0
  while(i < MAX_CHARACTER)
    target = FindByIndex(i)
    if(target && target != self)
      if(target.team != TEAM_GOOD)
        if(target.flags & (CHAR_CAN_RIDE_MOUNT | CHAR_CAN_BE_MOUNTED))
          // We've got a potential target...
          x = target.x-self.x
          y = target.y-self.y
          dis = x*x + y*y
          checkdis = (self.boxsize + target.boxsize)-0.5
          checkdis = checkdis*checkdis
          if(dis < checkdis)
            if((target.z+target.height) > self.z)
              // Make sure we've got the flags right...
              if(self.flags & CHAR_CAN_RIDE_MOUNT)
                // We're a rider looking for a mount...
                if(target.flags & CHAR_CAN_BE_MOUNTED)
                  if(target.rider >= MAX_CHARACTER)
                    if(target.team == self.team || target.team == TEAM_NEUTRAL)
                      // Found one...  Put our character on top of the mount...
                      self.z = target.z+target.height+0.01
                      return TRUE
              if(self.flags & CHAR_CAN_BE_MOUNTED)
                // We're a mount looking for a rider...
                if(target.flags & CHAR_CAN_RIDE_MOUNT)
                  if(target.mount >= MAX_CHARACTER)
                    if(target.team == self.team || self.team == TEAM_NEUTRAL)
                      if(target.daction == ACTION_STAND)
                        // Found one...  Put it on top of our character...
                        target.z = self.z+self.height+0.01
                        return TRUE
    i++
  return FALSE



//-----------------------------------------------------------------------
// Used to spawn crates and stuff on top of one another...
// Returns TRUE if it worked...
int PutOnPlatform()
  int self, target, i, found
  float x, y, dis, checkdis

  found = FALSE
  self = FindSelf()
  i = 0
  while(i < MAX_CHARACTER)
    target = FindByIndex(i)
    if(target && target != self)
      if(target.flags & CHAR_PLATFORM_ON)
        x = target.x-self.x
        y = target.y-self.y
        dis = x*x + y*y
        checkdis = (self.boxsize + target.boxsize)-0.5
        checkdis = checkdis*checkdis
        if(dis < checkdis)
          if((target.z+target.height) > self.z)
            self.z = target.z+target.height+0.01
            found = TRUE
    i++
  return found

//-----------------------------------------------------------------------
// Allows a swimming character to jump out of water when it hits a low wall...
// Should be called from Event()
int JumpOutOfWaterEvent()
  int self
  float x, y, z

  self = FindSelf()
  if(self.event == EVENT_HIT_WALL)
    if(self.flags & CHAR_IN_WATER)
      if(RoomWaterType() == WATER_TYPE_WATER)
        // Jump out of water...
        if(self.vz > -0.05 && self.action==ACTION_SWIM_FORWARD)
          x = self.x + (self.frontx*self.boxsize*2.0)
          y = self.y + (self.fronty*self.boxsize*2.0)
          z = RoomHeightXY(x, y)
          if(z > (self.z+2.0) && z < (self.z+5.0))
            if(z > (SystemGet(SYS_ROOMWATERLEVEL, 0, 0)*0.01))
              self.vz = 0.65
              self.action = ACTION_JUMP
              self.daction = ACTION_JUMP
              self.flags = self.flags | CHAR_FALL_ON
      else
        // Jump out of lava and sand...
        if(self.action==ACTION_WALK)
          x = self.x + (self.frontx*self.boxsize*2.0)
          y = self.y + (self.fronty*self.boxsize*2.0)
          z = RoomHeightXY(x, y)
          if(z > self.z && z < (self.z+7.0))
            self.vz = 0.50
            self.flags = self.flags | CHAR_FALL_ON
            self.cdtimer = 0

//-----------------------------------------------------------------------
// Small helper script for particle event function...  Causes
// a splash when particle hits water...  Also slows particle
// down and tweaks some other stuff...
int PartWaterEvent(float size)
  int self
  self = FindSelf()
//  if(self.event == EVENT_HIT_WATER)
//    StringClear(DEBUG_STRING)
//    StringAppend(DEBUG_STRING, "Particle Hit Water", 256)
//  if(self.event == EVENT_SPAWNED_IN_WATER)
//    StringClear(DEBUG_STRING)
//    StringAppend(DEBUG_STRING, "Particle Spawned In Water", 256)
  if(self.event == EVENT_HIT_WATER || self.event == EVENT_SPAWNED_IN_WATER)
    if(RoomWaterType() == WATER_TYPE_WATER)
      self.vx = self.vx * 0.5
      self.vy = self.vy * 0.5
      if(self.event == EVENT_HIT_WATER)
        PRIPPLE.Effect(self.x, self.y, size, 0.05, 24, 5)
    else
      self.event = EVENT_HIT_FLOOR


//-----------------------------------------------------------------------
// Gives us a generic difficulty multiplier for a character...
float SubtypeDifficulty(int subtype, float multiplier)
  float difficulty
  difficulty = 1.0 + ((RollDice(1, 21)-1) * 0.01)
  while(subtype > 0)
    difficulty = difficulty * multiplier
    subtype--


  // !!!BAD!!!
  // !!!BAD!!!
  // !!!BAD!!!
//  StringClear(String(0))
//  StringAppend(String(0), "Monster Difficulty == ", 256)
//  StringAppendNumber(String(0), difficulty, 256)
//  StringAppend(String(0), ".", 256)
//  StringAppendNumber(String(0), (difficulty-ToInt(difficulty)+0.05)*10.0, 256)
//  DebugMessage(String(0))
  // !!!BAD!!!
  // !!!BAD!!!
  // !!!BAD!!!

  return difficulty

//-----------------------------------------------------------------------
int TreasureModify(int item_type, float difficulty)
  if(item_type >= ITEM_HEAL && item_type <= ITEM_SUPER_MANA)
    item_type = ITEM_HEAL + RollDice(1, 2) - 1
    if(RollDice(1, 100) < (difficulty*5.0))
      item_type = item_type+2
  return item_type

//-----------------------------------------------------------------------
// Used to give a monster coins and keys and experience based on spawning difficulty...
int TreasureSetup(float difficulty, int experience, float money_multiplier, int item_common, int item_rare)
  int self
  self = FindSelf()


  // Make sure we're dealing with a monster (or neutral)...
  self.money = difficulty * ((RollDice(1, 100) + 30) * experience * money_multiplier) * 0.03 * NumLocalPlayer()
  difficulty = difficulty * sqrt(difficulty)
  self.expgive = experience*difficulty*GLOBAL_EXPERIENCE_MODIFIER
  if(self.expgive < 1 && experience > 0)
    self.expgive = 1
  if(self.money > MAX_MONEY)
    self.money = MAX_MONEY
  self.keys = RollDice(1, 8)>>3
  if(self.keys)
    self.money = 0


  // Sometimes give 'em rare items...
  if(item_rare != ITEM_NONE)
    if(RollDice(1, 100) > 90)
      self.keys = 0
      self.money = 0
      self.item00 = TreasureModify(item_rare, difficulty)


  // Sometimes give 'em common items...
  if(item_common != ITEM_NONE)
    if(RollDice(1, 100) > 70)
      self.keys = 0
      self.money = 0
      self.item00 = TreasureModify(item_common, difficulty)


  // Sometimes have nothing, so hearts get dropped...
  if(RollDice(1, 100) > 50)
    self.keys = 0
    self.money = 0


//-----------------------------------------------------------------------
// Used to make characters pushable by other characters...  Should be called in Event()...
int Pushable()
  int self, oldtarget, target
  float x, y, dot


  // Code to make pushable
  self = FindSelf()
  if(self.event == EVENT_HIT_CHARACTER)
    oldtarget = self.target
    self.target = SystemGet(SYS_COLLISIONCHAR, 0, 0)
    target = FindTarget()
    self.target = oldtarget
    if(target)
      if((target.action == ACTION_SWIM_FORWARD) && (target.flags & CHAR_CAN_RIDE_MOUNT) && (self.flags & CHAR_IN_WATER) && ((self.team == TEAM_NEUTRAL) || (self.team == target.team)) && (target.vz > -0.05))
        // Hop on the object...
        target.vz = 0.65
        target.action = ACTION_JUMP
        target.daction = ACTION_JUMP
        target.flags = target.flags | CHAR_FALL_ON
      else
        if(target.z > (self.z-2.0) && target.z < (self.z+(self.height*0.5)))
          x = (self.x - target.x)
          y = (self.y - target.y)
          dot = (x*target.vx) + (y*target.vy)
          if(dot > 0.0)
            self.vx = target.vx
            self.vy = target.vy
            target.vx = target.vx * 0.5
            target.vy = target.vy * 0.5

          if((target.team == TEAM_NEUTRAL || target.team == TEAM_MONSTER) && (self.team == TEAM_NEUTRAL || self.team == TEAM_MONSTER))
            dot = 0.25/(target.boxsize + self.boxsize + 0.5)
            if((self.flags & CHAR_IN_WATER))
              dot = dot * 0.1
            x = (target.x - self.x)*dot
            y = (target.y - self.y)*dot
            self.vx = self.vx - x
            self.vy = self.vy - y

          x = target.y-self.y
          y = self.x-target.x
          dot = (target.vx*x) + (target.vy*y)
          self.spin = self.spin - (dot*3000.0/self.boxsize)



//-----------------------------------------------------------------------
// Used to make potions & ammo automatically refill from inventory...
int AutoReload(int self, int grip)
  int offset, item_type, item_low, item_high, i

  offset = 242
  if(grip == MODEL_RIGHT_FILE)
    offset = 243
  if(grip == MODEL_LEFT2_FILE)
    offset = 244
  if(grip == MODEL_RIGHT2_FILE)
    offset = 245


  // Which type of item are we trying to reload?
  item_type = FileReadByte(self, offset)


  // Some items have a range to search
  item_low = item_type
  item_high = item_type
  if(item_type >= ITEM_QUIVER_10 && item_type <= ITEM_QUIVER_1)
    item_low = ITEM_QUIVER_10
    item_high = ITEM_QUIVER_1
  if(item_type >= ITEM_AMMO_10 && item_type <= ITEM_AMMO_1)
    item_low = ITEM_AMMO_10
    item_high = ITEM_AMMO_1



  // Look through the inventory for a matching item...
  i = 224
  while(i < 240)
    item_type = FileReadByte(self, i)
    if(item_type >= item_low && item_type <= item_high)
      // We found a matching item in the inventory...
      FileWriteByte(self, i, ITEM_NONE)
      FileWriteByte(self, offset, item_type)
      return TRUE
    i++


  // No matches...  Destroy the original item and give up...
  FileWriteByte(self, offset, ITEM_NONE)
  return FALSE


//-----------------------------------------------------------------------
// Gives some poison to the desired character, if able...
int PoisonCharacter(int character_index, int owner_index, int amount)
  int target, owner

  target = FindByIndex(character_index)
  owner = FindByIndex(owner_index)
  if(target && owner)
    if(target.pstimer < 32768 && !(target.sflags & SCRIPT_NO_POISON) && (target.team != owner.team || character_index == owner_index))
      if(target.team == TEAM_GOOD)
        // Don't poison as long for Good guys...
        target.pstimer = target.pstimer + (amount>>1)
      else
        // Normal effect...
        target.pstimer = target.pstimer + amount
      target.lasthit = owner_index

//-----------------------------------------------------------------------
// Petrifies the desired character, if able...
int PetrifyCharacter(int character_index, int owner_index, int amount)
  int target, owner, oldpttimer

  target = FindByIndex(character_index)
  owner = FindByIndex(owner_index)
  if(target && owner)
    if(!(target.sflags & SCRIPT_NO_PETRIFY) && (target.action != ACTION_KNOCK_OUT_BEGIN))
      oldpttimer = target.pttimer
      if(target.team == TEAM_GOOD)
        // Don't allow Good guys to be petrified when on ground or getting up...
        if(target.action < ACTION_KNOCK_OUT_BEGIN || target.action > ACTION_KNOCK_OUT_END)
          // Don't petrify as long either...
          target.pttimer = amount/3
          target.lasthit = owner_index
      else
        // Normal effect...
        target.pttimer = amount
        target.lasthit = owner_index
      if(target.pttimer > 0 && oldpttimer == 0)
        PFLASH.Effect(target, "FILE:LITESPRK.RGB", WHITE, TRUE, 1.0)


//-----------------------------------------------------------------------
// Deal damage to any character we bump...  Returns TRUE if we hit somebody...
int BumpDamageEvent(int damage_type, int damage_amount, int wound_amount, int knock_down, int blockable)
  int self, target, oldtarget
  float x, y, z, dotself, dottarget
  float distance


  self = FindSelf()
  if(self.event == EVENT_HIT_CHARACTER && self.rltimer == 0 && self.daction != ACTION_KNOCK_OUT && self.daction != ACTION_STUN && self.pttimer == 0)
    oldtarget = self.target
    self.target = SystemGet(SYS_COLLISIONCHAR, 0, 0)
    target = FindTarget()
    if(target)
      // We bumped somebody...
      if(target.team != self.team && (target.team != TEAM_NEUTRAL || self.team != TEAM_GOOD || self.aitimer == 0))
        // We bumped an enemy...
        if(target.z < (self.z + self.height*0.5) || (target.sflags & SCRIPT_BUMP_DAMAGE))
          // Target isn't jumping over us...


          // Bonus for Luck...
          if(self.team == TEAM_GOOD)
            if(SystemGet(SYS_LUCK, 0, 0))
              damage_amount++


          // Check for blocking and two bumpers running into one another...
          x = self.x - target.x
          y = self.y - target.y
          dotself = -(x*self.frontx + y*self.fronty)
          dottarget = x*target.frontx + y*target.fronty
          if(dottarget > 0.0 && target.daction == ACTION_BLOCK && blockable && target.pttimer == 0)
            // Attack has been blocked...
            PlaySound("FILE:BLOCK.RAW", 225 + RollDice(1, 50), 255)
            self.rltimer = 60
            self.vx = self.frontx * -0.25
            self.vy = self.fronty * -0.25
            self.vz = 0.25
            self.spin = self.spin+32768
            PSPARK.Effect(self.x, self.y, self.z, 10, 1)
          else
            distance = sqrt(x*x + y*y)
            if(distance > 0.0)
              dotself = dotself/distance
              dottarget = dottarget/distance
            if(self.team == TEAM_GOOD || target.daction == ACTION_STUN)
              // Self is given an advantage
              dotself = dotself + 1.0
            if(target.team == TEAM_GOOD || self.daction == ACTION_STUN)
              // Target is given an advantage
              dottarget = dottarget + 1.0

// !!!BAD!!!
// !!!BAD!!!
// !!!BAD!!!
//              StringClear(DEBUG_STRING)
//              SystemSet(SYS_CHARFASTFUNCTION, FindIndex(self), 0, FAST_FUNCTION_GETNAME)
//              StringAppend(DEBUG_STRING, NAME_STRING, 256)
//              StringAppend(DEBUG_STRING, " (", 256)
//              StringAppendNumber(DEBUG_STRING, dotself*100.0, 256)
//              StringAppend(DEBUG_STRING, ") vs ", 256)
//              SystemSet(SYS_CHARFASTFUNCTION, FindIndex(target), 0, FAST_FUNCTION_GETNAME)
//              StringAppend(DEBUG_STRING, NAME_STRING, 256)
//              StringAppend(DEBUG_STRING, " (", 256)
//              StringAppendNumber(DEBUG_STRING, dottarget*100.0, 256)
//              StringAppend(DEBUG_STRING, ")", 256)
//              DebugMessage(DEBUG_STRING)
// !!!BAD!!!
// !!!BAD!!!
// !!!BAD!!!

            if(!(target.sflags & SCRIPT_BUMP_DAMAGE) || dottarget < dotself || (target.vflags & VIRTUE_FLAG_BUMP_IMMUNE) < (self.vflags & VIRTUE_FLAG_BUMP_IMMUNE))
              // We're facing the target more than he's facing us (or we're immune and the target isn't)...
              if((target.vflags & VIRTUE_FLAG_BUMP_IMMUNE) <= (self.vflags & VIRTUE_FLAG_BUMP_IMMUNE))
                // Target is not immune to bump damage (or we're both immune)
                // Let's damage the target already...
                if(knock_down)
                  target.combo = 4
                DamageTarget(damage_type, damage_amount, wound_amount)
                x = (self.x + target.x)*0.5
                y = (self.y + target.y)*0.5
                z = self.z + 1.0
                PSPARK.Effect(x, y, z, 10, 0)

                if(self.team == TEAM_GOOD)
                  // Good guys can attack more frequently...
                  self.rltimer = 30
                  self.vx = self.frontx * -0.25
                  self.vy = self.fronty * -0.25
                else
                  // Monsters have a slower reload time...
                  self.rltimer = 60
                  self.vx = self.frontx * -0.5
                  self.vy = self.fronty * -0.5
                self.vz = 0.25

                self.spin = self.spin+32768
                self.target = oldtarget
                return TRUE
    self.target = oldtarget
  return FALSE

//-----------------------------------------------------------------------
ItemModelSetup(int grip)
  SystemSet(SYS_WEAPONGRIP, 0, 0, grip)
  SystemSet(SYS_WEAPONMODELSETUP, 0, 0, 0)

//-----------------------------------------------------------------------
ItemFrameEvent(int grip)
  SystemSet(SYS_WEAPONGRIP, 0, 0, grip)
  SystemSet(SYS_WEAPONFRAMEEVENT, 0, 0, 0)

//-----------------------------------------------------------------------
ItemEvent(int grip)
  SystemSet(SYS_WEAPONGRIP, 0, 0, grip)
  SystemSet(SYS_WEAPONEVENT, 0, 0, 0)

//-----------------------------------------------------------------------
ItemUnpressed(int grip)
  SystemSet(SYS_WEAPONGRIP, 0, 0, grip)
  SystemSet(SYS_WEAPONUNPRESSED, 0, 0, 0)

//-----------------------------------------------------------------------
// Returns TRUE if reload left is 0 and sets reload left to a standard
// delay time for magic spells/items...  Returns FALSE if unable to use
// because reload left is > 0...  Should be called in most magic & item
// scripts...
int ItemReload(int self)
  if(self.rltimer > 0)
    return FALSE
  self.rltimer = 30
  return TRUE

//-----------------------------------------------------------------------
// Generic weapon usage script...
WeaponAttackStart(int reload_time, int weapon_attack)
  int grip, self, dex
  grip = SystemGet(SYS_WEAPONGRIP, 0, 0)
  self = FindSelf()


  // Modify reload time by dexterity...
  dex = self.dex
  if(dex > 50)
    dex = 50
  reload_time = reload_time - ((dex*reload_time)/50)



  if(self.action == ACTION_WALK || self.action == ACTION_STAND || self.action == ACTION_JUMP || self.action == ACTION_DOUBLE)
    if(grip == MODEL_LEFT_FILE)
      if(self.rltimer == 0)            
        self.action = ACTION_BASH_LEFT
        if(weapon_attack & WEAPON_ATTACK_THRUST)
          self.action = ACTION_THRUST_LEFT
        if(weapon_attack & WEAPON_ATTACK_SLASH)
          self.action = ACTION_SLASH_LEFT
        self.daction = ACTION_STAND
        self.rltimer = reload_time
        ButtonHandled()
    else
      if(self.rrtimer == 0)
        self.action = ACTION_BASH_RIGHT
        if(weapon_attack & WEAPON_ATTACK_THRUST)
          self.action = ACTION_THRUST_RIGHT
        if(weapon_attack & WEAPON_ATTACK_SLASH)
          self.action = ACTION_SLASH_RIGHT
        self.daction = ACTION_STAND
        self.rrtimer = reload_time
        ButtonHandled()


//-----------------------------------------------------------------------
int GiveExperience()
  int self, killer_amount, team_amount, owner, mana_restore
  int target

  // Experience amount should be calculated on spawn...
  // Character who had last hit gets half that amount...
  // Characters who are on a different team each get half that amount (+1)...

  self = FindSelf()
  if(self.expgive > 0)
    self.target = self.lasthit
    target = FindTarget()
    team_amount = self.expgive>>1
    killer_amount = self.expgive - team_amount
    ExperienceFunction(self.target, EXPERIENCE_GIVE, killer_amount, FALSE)
    ExperienceFunction(FindIndex(self), EXPERIENCE_GIVE, team_amount, TRUE)


    // Give us Courage for defeating a monster...
    if(target)
      if(self.team != target.team && self.team != TEAM_NEUTRAL)
        if(self.hitsmax > 0)
          // Only get courage if not carrying a Wunnup's Cup...
          if(!CharacterHasItem(target, ITEM_ONE_UP, FALSE))
            // Get more courage when your own hits are low...
            killer_amount = ((killer_amount * (self.hitsmax-self.hits)) / (self.hitsmax * 5))
            ExperienceFunction(self.lasthit, EXPERIENCE_VIRTUE_COURAGE, killer_amount, FALSE)


  // Also add the character to the highscore table while we're at it...
  WHISCORE.AddCharacter(FindIndex(self))


//-----------------------------------------------------------------------
DamageAction()
  int self, direction, attacker
  float angle, x, y

  self = FindSelf()
  self.lasthit = SystemGet(SYS_GLOBALATTACKER, 0, 0)
  direction = SystemGet(SYS_GLOBALATTACKSPIN, 0, 0)
  self.dmtimer = 20
  self.intimer = 20
  if(self.eflags & ENCHANT_FLAG_LEVITATE)
    // Stop levitating if hit...
    self.flags = self.flags & (65535 - CHAR_HOVER_ON)
    self.flags = self.flags | CHAR_GRAVITY_ON
  if(self.eaction == 0)
    // Blink eyes
    self.eaction = 1
  attacker = FindByIndex(self.lasthit)
  if(self.action == ACTION_KNOCK_OUT || self.action == ACTION_KNOCK_OUT_END || self.daction == ACTION_KNOCK_OUT)
    if(self.action == ACTION_KNOCK_OUT)
      self.action = ACTION_KNOCK_OUT_STUN
    if(attacker)
      if(attacker.team != self.team)
        ExperienceFunction(self.lasthit, EXPERIENCE_VIRTUE_HONOR, -10, FALSE)
    if(self.hits < 1)
      // We're done for...
      if(self.pttimer > 0)
        CSTATUE.RubbleEffect(self.x, self.y, self.z, self.boxsize, self.height, FALSE)
        self.z = self.z+0.5
        GiveExperience()
        DeathEffect()
        if(!HelperRespawn())
          GoPoof(POOF_SELF)
      else
        PDUST.Effect(30)
        self.z = self.z+0.5
        GiveExperience()
        DeathEffect()
        if(!HelperRespawn())
          GoPoof(POOF_SELF)
  else
    self.combo++
    self.cbtimer = 0
    if(self.action < ACTION_KNOCK_OUT_BEGIN || self.action > ACTION_KNOCK_OUT_END)
      angle = (direction*360)/65536.0
      x = sin(angle+90.0)*0.5
      y = sin(angle)*0.5
      if(!(self.flags & CHAR_ON_GROUND))
        // We're not touching the ground...
        if(!(self.flags & CHAR_HOVER_ON))
          // And we're not a floaty character...
          if(!(self.flags & CHAR_IN_WATER))
            // And we're not in the water...  Means we're probably jumping...  Knock out right away...
            self.combo = 3
      if(self.sflags & SCRIPT_NO_KNOCK_OUT)
        // Don't allow knock down, unless we're out of hits...
        if(self.combo >= 3)
          Dismount()
        self.combo = 0
      if(self.hits < 1)
        // We're done for...  Knock out right away...
        self.combo = 3
        if(self.pttimer > 0)
          CSTATUE.RubbleEffect(self.x, self.y, self.z, self.boxsize, self.height, FALSE)
          self.z = self.z+0.5
          GiveExperience()
          DeathEffect()
          if(!HelperRespawn())
            GoPoof(POOF_SELF)
      if(self.combo < 3)
        // Normal hit
        self.action = ACTION_STUN_BEGIN
        self.daction = ACTION_STUN
        self.vx = x
        self.vy = y
        self.evtimer = 20
        if(self.team != TEAM_GOOD)
          // Monsters get stunned longer...
          self.evtimer = self.evtimer * 3
      else
        // Knock out hit
        self.pttimer = 0  // Turn off petrify...
//        if(self.hits > 0)  // Old thing to only give honor if not killin' 'em...
        attacker = FindByIndex(self.lasthit)
        if(attacker)
          if(attacker.team != self.team)
            ExperienceFunction(self.lasthit, EXPERIENCE_VIRTUE_HONOR, 1, FALSE)
        Dismount()
        self.combo = 0
        self.spin = direction+32768
        self.action = ACTION_KNOCK_OUT_BEGIN
        self.daction = ACTION_KNOCK_OUT
        self.evtimer = 80+RollDice(1, 40)
        if(self.team != TEAM_GOOD)
          // Monsters get knocked out longer...
          self.evtimer = self.evtimer * 3
        self.theight = self.height
        self.height = 3
        self.vx = x
        self.vy = y
        self.vz = 0.60
        self.flags = self.flags | CHAR_FALL_ON
        self.nctimer = 5 // 30


//-----------------------------------------------------------------------
int ButtonEvent()
  int self, event
  self = FindSelf()


  event = self.event & 3
  if(self.event & 8)
    if(event == BUTTON_LEFT)
      ItemUnpressed(MODEL_LEFT_FILE)
    if(event == BUTTON_RIGHT)
      ItemUnpressed(MODEL_RIGHT_FILE)
    if(event == BUTTON_SPECIAL1)
      ItemUnpressed(MODEL_LEFT2_FILE)
    if(event == BUTTON_SPECIAL2)
      ItemUnpressed(MODEL_RIGHT2_FILE)
    ButtonHandled()
    return 0
  else
    if(event == BUTTON_LEFT)
      ItemEvent(MODEL_LEFT_FILE)
      return 0
    if(event == BUTTON_RIGHT)
      ItemEvent(MODEL_RIGHT_FILE)
      return 0
    if(event == BUTTON_SPECIAL1)
      ItemEvent(MODEL_LEFT2_FILE)
      return 0
    if(event == BUTTON_SPECIAL2)
      ItemEvent(MODEL_RIGHT2_FILE)
      return 0

//-----------------------------------------------------------------------
// <ZZ> Little helpers...  For allowing only certain items to be
//      used when polymorph'd into certain monsters...
int RestrictItemPressed(int item)
  int self
  self = FindSelf()
  return ((item == ITEM_JUMP && !(self.flags&CHAR_HOVER_ON)) || (item >= ITEM_HEAL && item <= ITEM_SUPER_MANA) || (item >= ITEM_FISH && item <= ITEM_TRIPE) || item >= ITEM_SPELL_MISSILE)

//-----------------------------------------------------------------------
int RestrictItemUnpressed(int item)
  int self
  self = FindSelf()
  return (item == ITEM_JUMP || (item >= ITEM_HEAL && item <= ITEM_SUPER_MANA) || (item >= ITEM_FISH && item <= ITEM_TRIPE) || item >= ITEM_SPELL_MISSILE)

//-----------------------------------------------------------------------
int RestrictedButtonEvent()
  int self, event, worked
  self = FindSelf()


  event = self.event & 3
  if(self.event & 8)
    worked = FALSE
    if(event == BUTTON_LEFT)
      if(RestrictItemUnpressed(self.eqleft))
        ItemUnpressed(MODEL_LEFT_FILE)
        worked = TRUE
    if(event == BUTTON_RIGHT)
      if(RestrictItemUnpressed(self.eqright))
        ItemUnpressed(MODEL_RIGHT_FILE)
        worked = TRUE
    if(event == BUTTON_SPECIAL1)
      if(RestrictItemUnpressed(self.eqspec1))
        ItemUnpressed(MODEL_LEFT2_FILE)
        worked = TRUE
    if(event == BUTTON_SPECIAL2)
      if(RestrictItemUnpressed(self.eqspec2))
        ItemUnpressed(MODEL_RIGHT2_FILE)
        worked = TRUE
    ButtonHandled()
    return worked
  else
    if(event == BUTTON_LEFT)
      if(RestrictItemPressed(self.eqleft))
        ItemEvent(MODEL_LEFT_FILE)
        return TRUE
      return FALSE
    if(event == BUTTON_RIGHT)
      if(RestrictItemPressed(self.eqright))
        ItemEvent(MODEL_RIGHT_FILE)
        return TRUE
      return FALSE
    if(event == BUTTON_SPECIAL1)
      if(RestrictItemPressed(self.eqspec1))
        ItemEvent(MODEL_LEFT2_FILE)
        return TRUE
      return FALSE
    if(event == BUTTON_SPECIAL2)
      if(RestrictItemPressed(self.eqspec2))
        ItemEvent(MODEL_RIGHT2_FILE)
        return TRUE
      return FALSE
  return TRUE

//-----------------------------------------------------------------------
int AIUseTripe()
  int self
  self = FindSelf()

  // Try to use tripe if equipped...
  if(self.hits <= ((self.hitsmax+1)>>1))
    if(self.vflags & VIRTUE_FLAG_EATS_TRIPE)
      if(self.eqleft == ITEM_TRIPE)
        ButtonPress(BUTTON_PRESS, BUTTON_LEFT, 0)
        return TRUE
      if(self.eqright == ITEM_TRIPE)
        ButtonPress(BUTTON_PRESS, BUTTON_RIGHT, 0)
        return TRUE
      if(self.eqspec1 == ITEM_TRIPE)
        ButtonPress(BUTTON_PRESS, BUTTON_SPECIAL1, 0)
        return TRUE
      if(self.eqspec2 == ITEM_TRIPE)
        ButtonPress(BUTTON_PRESS, BUTTON_SPECIAL2, 0)
        return TRUE
  return FALSE

//-----------------------------------------------------------------------
int AIUseMeat()
  int self
  self = FindSelf()

  // Try to use meat/porc/fish if equipped...
  if(self.hits <= ((self.hitsmax+1)>>1))
    if(self.eqleft >= ITEM_FISH && self.eqleft <= ITEM_PORC_ROTTEN)
      ButtonPress(BUTTON_PRESS, BUTTON_LEFT, 0)
      return TRUE
    if(self.eqright >= ITEM_FISH && self.eqright <= ITEM_PORC_ROTTEN)
      ButtonPress(BUTTON_PRESS, BUTTON_RIGHT, 0)
      return TRUE
    if(self.eqspec1 >= ITEM_FISH && self.eqspec1 <= ITEM_PORC_ROTTEN)
      ButtonPress(BUTTON_PRESS, BUTTON_SPECIAL1, 0)
      return TRUE
    if(self.eqspec2 >= ITEM_FISH && self.eqspec2 <= ITEM_PORC_ROTTEN)
      ButtonPress(BUTTON_PRESS, BUTTON_SPECIAL2, 0)
      return TRUE
  return FALSE

//-----------------------------------------------------------------------
int AIUsePotions()
  int self
  self = FindSelf()

  // Try to use a healing potion if equipped...
  if(self.hits <= ((self.hitsmax-self.hitstap+1)>>1))
    if(self.eqleft == ITEM_HEAL || self.eqleft == ITEM_SUPER_HEAL)
      ButtonPress(BUTTON_PRESS, BUTTON_LEFT, 0)
      return TRUE
    if(self.eqright == ITEM_HEAL || self.eqright == ITEM_SUPER_HEAL)
      ButtonPress(BUTTON_PRESS, BUTTON_RIGHT, 0)
      return TRUE
    if(self.eqspec1 == ITEM_HEAL || self.eqspec1 == ITEM_SUPER_HEAL)
      ButtonPress(BUTTON_PRESS, BUTTON_SPECIAL1, 0)
      return TRUE
    if(self.eqspec2 == ITEM_HEAL || self.eqspec2 == ITEM_SUPER_HEAL)
      ButtonPress(BUTTON_PRESS, BUTTON_SPECIAL2, 0)
      return TRUE
  if(self.manamax > 0)
    if(self.mana <= ((self.manamax-self.manatap+1)>>1))
      if(self.eqleft == ITEM_MANA || self.eqleft == ITEM_SUPER_MANA)
        ButtonPress(BUTTON_PRESS, BUTTON_LEFT, 0)
        return TRUE
      if(self.eqright == ITEM_MANA || self.eqright == ITEM_SUPER_MANA)
        ButtonPress(BUTTON_PRESS, BUTTON_RIGHT, 0)
        return TRUE
      if(self.eqspec1 == ITEM_MANA || self.eqspec1 == ITEM_SUPER_MANA)
        ButtonPress(BUTTON_PRESS, BUTTON_SPECIAL1, 0)
        return TRUE
      if(self.eqspec2 == ITEM_MANA || self.eqspec2 == ITEM_SUPER_MANA)
        ButtonPress(BUTTON_PRESS, BUTTON_SPECIAL2, 0)
        return TRUE
  return FALSE


//-----------------------------------------------------------------------
AIPitAvoidance()
  int self, found_pit
  float x, y, z, distance, depth


  self = FindSelf()
  found_pit = FALSE
  distance = 0.50
  depth = 10.0
  while(distance < 8.0)
    x = self.x + self.frontx*distance
    y = self.y + self.fronty*distance
    z = RoomHeightXY(x, y)
    if(z < (self.z-depth))
      // There's a big drop
      found_pit = TRUE
      distance = 100.0
    x = self.x + self.frontx*distance + self.sidex*distance*0.5
    y = self.y + self.fronty*distance + self.sidey*distance*0.5
    z = RoomHeightXY(x, y)
    if(z < (self.z-depth))
      // There's a big drop
      found_pit = TRUE
      distance = 100.0
    x = self.x + self.frontx*distance - self.sidex*distance*0.5
    y = self.y + self.fronty*distance - self.sidey*distance*0.5
    z = RoomHeightXY(x, y)
    if(z < (self.z-depth))
      // There's a big drop
      found_pit = TRUE
      distance = 100.0
    distance = distance + 1.0


  if(found_pit)
    self.gotox = self.x
    self.gotoy = self.y
    // Left check...
    x = self.x + self.sidex*5.0
    y = self.y + self.sidey*5.0
    z = AreaHeightXY(x, y, 1.0)
    if(z > (self.z-depth))
      self.gotox = x
      self.gotoy = y
    else
      // Right check...
      x = self.x - self.sidex*5.0
      y = self.y - self.sidey*5.0
      z = AreaHeightXY(x, y, 1.0)
      if(z > (self.z-depth))
        self.gotox = x
        self.gotoy = y
      else
        // Back check...
        x = self.x - self.frontx*5.0
        y = self.y - self.fronty*5.0
        z = AreaHeightXY(x, y, 1.0)
        if(z > (self.z-depth))
          self.gotox = x
          self.gotoy = y
    self.aitimer = 20



//-----------------------------------------------------------------------

int AIIsStuck()
  int self
  float height, distance, x, y, z

  self = FindSelf()
  height = 2.0
  distance = 0.50
  while(distance < 2.0)
    x = self.x + self.frontx*distance
    y = self.y + self.fronty*distance
    z = RoomHeightXY(x, y)
    if(z > (self.z+height))
      return TRUE
    x = self.x + self.frontx*distance + self.sidex*distance*0.25
    y = self.y + self.fronty*distance + self.sidey*distance*0.25
    z = RoomHeightXY(x, y)
    if(z > (self.z+height))
      return TRUE
    x = self.x + self.frontx*distance - self.sidex*distance*0.25
    y = self.y + self.fronty*distance - self.sidey*distance*0.25
    z = RoomHeightXY(x, y)
    if(z > (self.z+height))
      return TRUE
    distance = distance + 1.0
  return FALSE

//-----------------------------------------------------------------------

int AIScript()
  int self, target, mount, rider, index, temp
  float x, y, distance, angle
  self = FindSelf()
  self.aitimer = 10 + RollDice(1, 10)




  // Spend any stat points we've got lying around...
  if(self.statpts > 0)
    self.statpts--
    if(self.hitsmax < 100)
      self.hitsmax++
      self.hits++



  if(self.daction == ACTION_KNOCK_OUT)
    if(self.aistate == STANDARD_AISTATE_WANDER || self.aistate == STANDARD_AISTATE_STAND || self.aistate == STANDARD_AISTATE_CHARGE || STANDARD_AISTATE_DOOR)
      self.aistate = STANDARD_AISTATE_ATTACK

  // Stand your ground...
  if (self.aistate == STANDARD_AISTATE_STAND)
    target = FindByIndex(AcquireTarget(ACQUIRE_SEE_BEHIND | ACQUIRE_SEE_ENEMY, NULL, 25.0))
    if (target)
      if(GetDirection(target.x, target.y) == DIRECTION_FRONT)
        x = self.x - target.x
        y = self.y - target.y
        distance = x*x + y*y
        x = self.boxsize + target.boxsize + 2.0
        if(distance < (x*x))
          // Close enough to strike...
          self.gotox = target.x
          self.gotoy = target.y
          ButtonPress(BUTTON_PRESS, BUTTON_RIGHT, 0)
        else
          // Defend
          if((self.eqleft & 248) == ITEM_SHIELD)
            ButtonPress(BUTTON_PRESS_AND_HOLD, BUTTON_LEFT, 40)
      else
        self.gotox = target.x
        self.gotoy = target.y

  // Charge towards target...
  if(self.aistate == STANDARD_AISTATE_ATTACK || self.aistate == STANDARD_AISTATE_ATTACK_FOLLOW || self.aistate == STANDARD_AISTATE_CHARGE)
    self.target = AcquireTarget(ACQUIRE_SEE_BEHIND | ACQUIRE_SEE_ENEMY, NULL, 500.0)
    target = FindTarget()
    if(target)
      self.gotox = target.x
      self.gotoy = target.y
      FindPath()

      mount = FindByIndex(self.mount)
      if(mount)
        if(SystemGet(SYS_CHARACTERSCRIPTFILE, 0, self.mount) == "FILE:CTANKE.RUN")
          x = target.x - self.x
          y = target.y - self.y
          distance = x*self.sidex + y*self.sidey
          if(distance < -2.0)
            ButtonPress(BUTTON_PRESS_AND_HOLD, BUTTON_RIGHT, self.aitimer)
          if(distance > 2.0)
            ButtonPress(BUTTON_PRESS_AND_HOLD, BUTTON_LEFT, self.aitimer)
          if(distance > -2.0 && distance < 2.0)
            distance = x*self.frontx + y*self.fronty
            if(distance > 0.0)
              ButtonPress(BUTTON_PRESS_AND_HOLD, BUTTON_SPECIAL2, 60)
        else
          if(GetDirection(target.x, target.y) == DIRECTION_FRONT)
            // Fire at will
            self.gotox = target.x
            self.gotoy = target.y
            if(RollDice(1, 4) == 1)
              ButtonPress(BUTTON_PRESS_AND_HOLD, BUTTON_SPECIAL2, 60)
            else
              ButtonPress(BUTTON_PRESS_AND_HOLD, BUTTON_RIGHT, 20)
      else
        x = self.x - target.x
        y = self.y - target.y
        distance = x*x + y*y
        if (self.eqright == ITEM_NONE || (self.eqright & 248) == ITEM_DAGGER || (self.eqright & 248) == ITEM_HAMMER)
          x = self.boxsize + target.boxsize + 2.0
        else
          x = self.boxsize + target.boxsize + 3.0
        if (distance < (x*x))
          // Close enough to strike...
          if(GetDirection(target.x, target.y) == DIRECTION_FRONT)
            if (self.rrtimer == 0)
              // We're facing the enemy...
              self.gotox = target.x
              self.gotoy = target.y
              ButtonPress(BUTTON_PRESS, BUTTON_RIGHT, 0)
              self.aitimer = 10
            else
              // Enemy is near but we are not ready to hit...
              if ((self.eqleft & 248) == ITEM_SHIELD)
                ButtonPress(BUTTON_PRESS_AND_HOLD, BUTTON_LEFT, 40)
                self.aitimer = 10
        else
          if ((target.sflags & SCRIPT_BUMP_DAMAGE) || (RollDice(1, 10) == 1))
            x = self.boxsize + target.boxsize + 10.0
            if(distance < (x*x) && self.eqspec1 == ITEM_JUMP && self.rrtimer > 0)
              x = self.x - target.x
              y = self.y - target.y
              self.gotox = self.x + (x*5.0)
              self.gotoy = self.y + (y*5.0)
              ButtonPress(BUTTON_PRESS_AND_HOLD, BUTTON_SPECIAL1, 30)
              self.aitimer = 30
          if (AIIsStuck())
            ButtonPress(BUTTON_PRESS, BUTTON_SPECIAL1, 0)
          // Randomly break off attack...
          if(self.aistate != STANDARD_AISTATE_CHARGE && RollDice(1, 100) > 80)
            self.aistate = STANDARD_AISTATE_WANDER
            if(self.aistate == STANDARD_AISTATE_ATTACK_FOLLOW)
              self.aistate = STANDARD_AISTATE_FOLLOW
            if(self.flags & CHAR_CAN_RIDE_MOUNT)
              if(!FindByIndex(self.mount))
                target = FindByIndex(AcquireTarget(ACQUIRE_SEE_BEHIND | ACQUIRE_SEE_FRIENDLY | ACQUIRE_SEE_NEUTRAL | ACQUIRE_OPEN_MOUNT_ONLY, NULL, 50.0))
                if(target)
                  self.aistate = STANDARD_AISTATE_MOUNT
    else
      if(self.aistate == STANDARD_AISTATE_ATTACK)
        self.aistate = STANDARD_AISTATE_WANDER
      else
        self.aistate = STANDARD_AISTATE_FOLLOW




  // Follow the biggest nearby friendly...
  if(self.aistate == STANDARD_AISTATE_FOLLOW)
    self.target = AcquireTarget(ACQUIRE_SEE_BEHIND | ACQUIRE_SEE_FRIENDLY, NULL, 75.0)
    target = FindTarget()
    if(target)
      rider = FindByIndex(target.rider)
      if(rider)
        self.target = target.rider
        target = rider
      if(target.target == FindIndex(self) || target.target == self.mount)
        self.aistate = STANDARD_AISTATE_WANDER
      else
        self.gotox = target.x - target.frontx*10.0
        self.gotoy = target.y - target.fronty*10.0
        if(self.flags & CHAR_CAN_RIDE_MOUNT)
          if(!FindByIndex(self.mount))
            target = FindByIndex(AcquireTarget(ACQUIRE_SEE_BEHIND | ACQUIRE_SEE_FRIENDLY | ACQUIRE_SEE_NEUTRAL | ACQUIRE_OPEN_MOUNT_ONLY, NULL, 15.0))
            if(target)
              self.aistate = STANDARD_AISTATE_MOUNT
        target = FindByIndex(AcquireTarget(ACQUIRE_SEE_BEHIND | ACQUIRE_SEE_ENEMY, NULL, 25.0))
        if(target)
          self.aistate = STANDARD_AISTATE_ATTACK_FOLLOW
        else
          self.aitimer = self.aitimer << 1
    else
      self.aistate = STANDARD_AISTATE_WANDER
    


  // Try to jump on a mount if we're able to...
  if(self.aistate == STANDARD_AISTATE_MOUNT)
    self.aistate = STANDARD_AISTATE_WANDER
    mount = FindByIndex(self.mount)
    if(!mount)
      if(self.flags & CHAR_CAN_RIDE_MOUNT)
        self.target = AcquireTarget(ACQUIRE_SEE_BEHIND | ACQUIRE_SEE_FRIENDLY | ACQUIRE_SEE_NEUTRAL | ACQUIRE_OPEN_MOUNT_ONLY, NULL, 75.0)
        target = FindTarget()
        if(target)
          if(target.z > RoomWaterLevel())
            self.gotox = target.x
            self.gotoy = target.y
            self.aitimer = self.aitimer << 1
            if(FindPath())
              self.aistate = STANDARD_AISTATE_MOUNT
              x = self.x - target.x
              y = self.y - target.y
              distance = x*x + y*y
              x = self.boxsize + target.boxsize + 6.0
              if(distance < (x*x))
                // Close enough to jump on mount...
                ButtonPress(BUTTON_PRESS, BUTTON_SPECIAL1, 0)
                self.aistate = STANDARD_AISTATE_FOLLOW
              else
                // Still trying to get to mount...
                if(RollDice(1, 100) > 90)
                  // Randomly give up...
                  self.aistate = STANDARD_AISTATE_WANDER




  // Wander around aimlessly until we find a target...
  if(self.aistate == STANDARD_AISTATE_WANDER)
    self.aitimer = self.aitimer << 2
    self.gotox = self.x + (RollDice(1, 19) - 10.0)*5.0
    self.gotoy = self.y + (RollDice(1, 19) - 10.0)*5.0
    if(!FindPath())
      self.gotox = self.x
      self.gotoy = self.y
      self.aitimer = 1
    if(RollDice(1, 100) > 50)
      // Try switching modes randomly...
      self.aistate = RollDice(1, 4)&3
    if(FindByIndex(AcquireTarget(ACQUIRE_SEE_BEHIND | ACQUIRE_SEE_ENEMY, NULL, 25.0)))
      self.aistate = STANDARD_AISTATE_ATTACK



  // Rally is used by ITalk...  Target should be set...
  if(self.aistate == STANDARD_AISTATE_RALLY)
    target = FindTarget()
    if(target)
      distance = 0.0
      temp = self.aimode%3
      if(temp == 1)
        distance = 5.0
      if(temp == 2)
        distance = -5.0
      angle = (self.aimode/3)*5.0
      self.gotox = target.x + target.sidex*distance - target.frontx*angle
      self.gotoy = target.y + target.sidey*distance - target.fronty*angle
      x = self.gotox-self.x
      y = self.gotoy-self.y
      FindPath()
      // Break off rally to fight nearby enemies...
      distance = x*x + y*y
      if(distance < 25.0)
        // We're at the rally...
        target = FindByIndex(AcquireTarget(ACQUIRE_SEE_BEHIND | ACQUIRE_SEE_ENEMY, NULL, 15.0))
        if(target)
          self.aistate = STANDARD_AISTATE_ATTACK_FOLLOW
          self.aitimer = 1
      else
        mount = FindByIndex(self.mount)
        if(!mount && AIIsStuck())
          // Try to jump if we are stuck, and not at the destination yet
          ButtonPress(BUTTON_PRESS, BUTTON_SPECIAL1, 0)

  if(self.aistate == STANDARD_AISTATE_DOOR)
    target = FindTarget()
    if(target)
      self.gotox = target.x
      self.gotoy = target.y
      x = self.gotox-self.x
      y = self.gotoy-self.y
      FindPath()
      distance = x*x + y*y
      if(distance < 25.0)
        // We're at the door...
        self.gotox = self.x
        self.gotoy = self.y
        self.aistate = STANDARD_AISTATE_STAND
        self.aitimer = 1
      else
        mount = FindByIndex(self.mount)
        if(!mount && AIIsStuck())
          // Try to jump if we are stuck, and not at the destination yet
          ButtonPress(BUTTON_PRESS, BUTTON_SPECIAL1, 0)
    else
      self.aistate = STANDARD_AISTATE_ATTACK


  // Standard pit avoidance hack...
  if(!(self.flags & (CHAR_HOVER_ON | CHAR_IN_WATER)))
    AIPitAvoidance()



//-----------------------------------------------------------------------
int Event()
  int self, index, child
  float angle, x, y, z, size, dx, dy, dis
  self = FindSelf()


  if(self.event == EVENT_FELL_IN_PIT)
    GiveExperience()
    Dismount()
    if(!HelperRespawn())
      GoPoof(POOF_SELF)
    return 0
  if(self.event == EVENT_HIT_FLOOR)
    if(self.daction == ACTION_JUMP)
      self.daction = ACTION_STAND
      self.action = ACTION_JUMP_END
      return 0
    if(self.daction == ACTION_DOUBLE)
      self.daction = ACTION_STAND
      self.action = ACTION_DOUBLE_END
      return 0
    if(self.daction == ACTION_KNOCK_OUT || self.hits < 1)
      self.gotox = self.x
      self.gotoy = self.y
      if(self.z > RoomWaterLevel())
        if(self.hits > 0 || self.pttimer == 0)
          PDUST.Effect(30)
        SystemSet(SYS_SCREENSHAKE, 0, 2, 15)
      if(self.hits < 1)
        if(self.pttimer > 0)
          CSTATUE.RubbleEffect(self.x, self.y, self.z, self.boxsize, self.height, FALSE)
        // We're done for...
        self.z = self.z+0.5
        GiveExperience()
        DeathEffect()
        if(!HelperRespawn())
          GoPoof(POOF_SELF)
    return 0
  if(self.event == EVENT_TIMER)
    if(self.daction == ACTION_STUN)
      self.action = ACTION_STUN_END
      self.daction = ACTION_STAND
    if(self.daction == ACTION_KNOCK_OUT)
      if(self.pttimer > 0)
        // Don't let petrified guys wake until they're ready...
        self.evtimer = self.pttimer
        return 0
      // Get back up...
      self.gotox = self.x
      self.gotoy = self.y
      self.action = ACTION_KNOCK_OUT_END
      self.daction = ACTION_STAND
      self.combo = 0
      if(self.team != TEAM_MONSTER)
        // Allow good guys to stand up and run away...
        self.intimer = 75
        if(!(self.flags & CHAR_CAN_BE_MOUNTED))
          // Only let non-mounts run through enemies...
          // Otherwise player might try to jump back on mount
          // and not be able to...
          self.nctimer = 100
      else
        self.intimer = 40
      self.height = self.theight
    if(self.daction == ACTION_SWIM)
      // Probably got knocked into water...  Need to set
      // height properly...
      if(self.theight > self.height && self.theight < 100)
        self.height = self.theight
    return 0
  if(self.event == EVENT_DAMAGED)
    PlaySound("FILE:HIT.RAW", 225 + RollDice(1, 50), 255)
    DamageAction()
    return 0
  if(self.event == EVENT_BLOCKED)
    if(!(self.eflags & ENCHANT_FLAG_MIRROR_DEFLECT))
      angle = (self.spin*360)/65536.0
      x = sin(angle+90.0)
      y = sin(angle)
      self.vx = -0.5*x
      self.vy = -0.5*y
    return 0
  if(self.event == EVENT_RIPPLE)
    size = self.boxsize+0.50
    PRIPPLE.Effect(self.x, self.y, size, 0.05, 25, RollDice(1, 5)+10)
    return 0
  if(self.event == EVENT_DROWN)
    PDROWN.Effect(self.x, self.y, self.z+(self.height-1), 10)
    return 0
  if(self.event == EVENT_HIT_WATER)
    if(self.vz < -0.25)
      PSPLASH.Effect(self.x, self.y, self.boxsize*1.15)
    return 0
  if(self.event == EVENT_DISMOUNTED)
    if(self.flags & CHAR_CAN_RIDE_MOUNT)
      FixCharacterLocation(self)
    if(self.aitimer > 0)
      self.aitimer = 1
    return 0
  if(self.event == EVENT_NETWORK_UPDATE)
    x = (SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_X) - 512) * 0.25
    y = (SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_Y) - 512) * 0.25
    z = SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_Z) * 0.5
    self.gotox = x
    self.gotoy = y
    self.hoverz = (RoomHeightXY(x, y) + z)
    self.x = (self.x*0.95 + x*0.05)
    self.y = (self.y*0.95 + y*0.05)
    dx = x - self.x
    dy = y - self.y
    dis = sqrt(dx*dx + dy*dy)
    self.dex = 10.0 + dis
    self.aitimer = 50
    self.hitsmax = 50
    self.hits = 50
    self.hitstap = 0
    self.action = SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_ACTION)
    // Special action handling...
    if(self.action == ACTION_WALK || self.action == ACTION_STAND)
      self.daction = self.action
      if(dis < 2.0 && self.action == ACTION_STAND)
        self.spin = (SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_FACING) << 8)
      if((self.z < self.hoverz-2.0) && !(self.flags & CHAR_HOVER_ON))
        self.action = ACTION_JUMP
    if(self.action != ACTION_STAND && self.action != ACTION_WALK)
      self.x = (self.x*0.95 + x*0.05)
      self.y = (self.y*0.95 + y*0.05)
      self.spin = (SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_FACING) << 8)
      if(self.action >= ACTION_BLOCK_BEGIN && self.action <= ACTION_BLOCK)
        self.daction = ACTION_BLOCK
      if(self.action >= ACTION_STUN_BEGIN && self.action <= ACTION_STUN)
        self.daction = ACTION_STUN
        self.evtimer = 20
      if(self.action >= ACTION_KNOCK_OUT_BEGIN && self.action <= ACTION_KNOCK_OUT_STUN)
        self.daction = ACTION_KNOCK_OUT
      if(self.action >= ACTION_JUMP_BEGIN && self.action <= ACTION_JUMP)
        if(self.daction != ACTION_JUMP)
          self.vz = 0.65
          self.daction = ACTION_JUMP
        self.flags = self.flags | CHAR_FALL_ON
        self.flags = self.flags & (65535-CHAR_ON_PLATFORM)
      if(self.action >= ACTION_DOUBLE_BEGIN && self.action <= ACTION_DOUBLE)
        if(self.daction != ACTION_DOUBLE)
          self.vz = 0.65
          self.daction = ACTION_DOUBLE
        self.flags = self.flags | CHAR_FALL_ON
        self.flags = self.flags & (65535-CHAR_ON_PLATFORM)



    self.team = SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_TEAM)
    self.pstimer = SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_POISON)<<6
    self.pttimer = SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_PETRIFY)<<6
    self.alpha = (self.alpha + SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_ALPHA))>>1

    self.eqleft = SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_EQLEFT)
    self.eqright = SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_EQRIGHT)
    self.eqcol01 = SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_EQCOL01)
    if(SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_EXTRA_DATA))
      self.eqcol23 = SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_EQCOL23)
      self.eqspec1 = SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_EQSPEC1)
      self.eqspec2 = SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_EQSPEC2)
      self.eqhelm = SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_EQHELM)
      self.eqbody = SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_EQBODY)
      self.eqlegs = SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_EQLEGS)
      self.class = SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_CLASS)


    if(SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_NEWLY_SPAWNED))
      self.flatten = 60
      self.spin = (SystemGet(SYS_NETWORKSCRIPT, 0, NETWORK_SCRIPT_FACING) << 8)
      self.frame = SystemGet(SYS_MODELACTIONSTART, NULL, self.action)
      if(self.frame == 65535)
        self.frame = SystemGet(SYS_MODELACTIONSTART, NULL, ACTION_STAND)
        if(self.frame == 65535)
          self.frame = 0

      // Do a portal effect depending on team...
      x = self.x
      y = self.y
      z = self.z
      if(self.team == TEAM_MONSTER || self.team == TEAM_EVIL)
        PPORTAL.Effect(x, y, z+0.1, self.spin, 0)
        PPORTAL.Effect(x, y, z+0.1, self.spin, 1)
        child = PSMOKE.Effect(x, y, z+0.5, 0.0, 0.0, 0.0, 11.0, 0.0, FALSE, WHITE, 255, 130)
        if(child)
          child.image = "FILE:SHADPORT.RGB"
          child.vspin = 0
          child.spin = self.spin
          child.flags = PART_FLAT_ON | PART_SPIN_ON
      else
        PFLASH.FocusEffect(x, y, z+(self.height*0.5), (self.boxsize+self.height), "FILE:LITESPRK.RGB", 25)
        PFLASH.Effect(self, "FILE:LITESPRK.RGB", WHITE, TRUE, 1.5)
        PFLASH.Effect(self, "FILE:LITESPRK.RGB", (128<<16) | (128<<8) | 128, TRUE, 4.0)




    index = FindIndex(self)
    SystemSet(SYS_CHARFASTFUNCTION, index, 0, FAST_FUNCTION_MODELSETUP)
    SystemSet(SYS_CHARFASTFUNCTION, index, 0, FAST_FUNCTION_DEFENSERATING)



    return 0
  if(self.pttimer > 0)
    STANDARD.Pushable()


//-----------------------------------------------------------------------
int FrameEvent()
  int self
  self = FindSelf()

  if(self.event & 8)
    // Spawn an attack particle...
    if(self.action == ACTION_SLASH_LEFT || self.action == ACTION_BASH_LEFT || self.action == ACTION_THRUST_LEFT || self.action == ACTION_BOW_LEFT || self.action == ACTION_BOW_LEFT_ARC)
      ItemFrameEvent(MODEL_LEFT_FILE)
    if(self.action == ACTION_SLASH_RIGHT || self.action == ACTION_BASH_RIGHT || self.action == ACTION_THRUST_RIGHT || self.action == ACTION_GONNE_RIGHT)
      ItemFrameEvent(MODEL_RIGHT_FILE)

//-----------------------------------------------------------------------
// Eye blink...
int Refresh()
  int self
  self = FindSelf()
  self.timer = 200 + (RollDice(1, 5)*20)
  self.eaction = 1


//-----------------------------------------------------------------------
int BossDefeatStart()
  int self

  self = FindSelf()
  if(!(self.sflags & SCRIPT_BOSS_DEFEAT))
    MapObjectDefeated()
    self.evtimer = 0
    self.nctimer = 400
    self.vx = self.vx*0.5
    self.vy = self.vy*0.5
    Dismount()
    self.flags = self.flags & (65535-CHAR_CAN_BE_MOUNTED)
    self.sflags = self.sflags | SCRIPT_BOSS_DEFEAT
    self.timer = 1
    if(self.aitimer)
      self.aitimer = 1000
    self.vspin = 0


//-----------------------------------------------------------------------
int BossDefeatRefresh()
  int self, angle, i, volume
  float z, halfheight, center

  self = FindSelf()
  if(self.sflags & SCRIPT_BOSS_DEFEAT)
    self.timer = 1
    if(self.bright > 0)
      self.bright--


    halfheight = self.theight * 0.5
    center = self.z + halfheight
    if(self.nctimer > 25 && self.nctimer < 350)
      if(RollDice(1, 38) > (self.nctimer>>2)-50)
        z = (((self.theight * RollDice(1, 256) * 0.00390625) - halfheight) * 1.50) + center
        angle = (RollDice(1, 256) * 360) >> 8
        PBOSS.SparkEffect(self.x, self.y, z, self.boxsize*3.0, angle, center)
        z = (((self.theight * RollDice(1, 256) * 0.00390625) - halfheight) * 1.50) + center
        angle = (RollDice(1, 256) * 360) >> 8
        PBOSS.SparkEffect(self.x, self.y, z, self.boxsize*3.0, angle, center)
        volume = (500 - self.nctimer)>>5
        if(RollDice(1, 3) == 1)
          PlaySound("FILE:-XYLO1.RAW", 128, volume)


    if(RollDice(1, 50) > (self.nctimer>>2))
      z = (((self.theight * RollDice(1, 256) * 0.00390625) - halfheight) * 0.75) + center
      angle = (RollDice(1, 256) * 360) >> 8
      PBOSS.ShaftEffect(self.x, self.y, z, self.boxsize*0.65, angle, center)
      volume = (500 - self.nctimer)>>5
      if(RollDice(1, 3) == 1)
        PlaySound("FILE:-STATU01.RAW", 128, volume)


    if(self.nctimer < 1)
      PBOSS.BurstEffect(self.x, self.y, center, FALSE)
      PBOSS.BurstEffect(self.x, self.y, center, TRUE)
      PBOSS.LittleBurstEffect(self.x, self.y, center, FALSE)
      PBOSS.LittleBurstEffect(self.x, self.y, center, TRUE)
      i = 0
      while(i < 200)
        z = (((self.theight * RollDice(1, 256) * 0.00390625) - halfheight) * 0.50) + center
        angle = (RollDice(1, 256) * 360) >> 8
        PBOSS.DebrisEffect(self.x, self.y, z, self.boxsize*0.65, angle, center)
        i++
      SystemSet(SYS_SCREENSHAKE, 0, 8, 20)
      GiveExperience()
      PlaySound("FILE:-STRING1.RAW", 384, 255)
      PlaySound("FILE:BAD4.RAW", 384, 64)
      if(!HelperRespawn())
        GoPoof(POOF_SELF)
    return TRUE
  return FALSE

//-----------------------------------------------------------------------
// Standard eye textures...
int EyeSetup(int location, int team)
  if(team == TEAM_NEUTRAL || team == TEAM_GOOD)
    // Good or neutral...
    ModelAssign(location, "FILE:=EYE0.RGB")
  else
    // Monster or evil...
    ModelAssign(location, "FILE:=EYE1.RGB")

//-----------------------------------------------------------------------
